(function(e){function n(n){for(var o,s,r=n[0],l=n[1],c=n[2],h=0,d=[];h<r.length;h++)s=r[h],i[s]&&d.push(i[s][0]),i[s]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(e[o]=l[o]);p&&p(n);while(d.length)d.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var e,n=0;n<a.length;n++){for(var t=a[n],o=!0,r=1;r<t.length;r++){var l=t[r];0!==i[l]&&(o=!1)}o&&(a.splice(n--,1),e=s(s.s=t[0]))}return e}var o={},i={1:0},a=[];function s(n){if(o[n])return o[n].exports;var t=o[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.m=e,s.c=o,s.d=function(e,n,t){s.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},s.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,n){if(1&n&&(e=s(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)s.d(t,o,function(n){return e[n]}.bind(null,o));return t},s.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return s.d(n,"a",n),n},s.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},s.p="/";var r=window["webpackJsonp"]=window["webpackJsonp"]||[],l=r.push.bind(r);r.push=n,r=r.slice();for(var c=0;c<r.length;c++)n(r[c]);var p=l;a.push([9,0]),t()})({"0bEL":function(e,n,t){"use strict";var o=t("dI4h"),i=t.n(o);i.a},9:function(e,n,t){e.exports=t("Vtdi")},Drq1:function(e,n,t){},IajB:function(e,n,t){"use strict";var o=t("Yb3g"),i=t.n(o);i.a},KHRh:function(e,n,t){"use strict";var o=t("dtHW"),i=t.n(o);i.a},Vtdi:function(e,n,t){"use strict";t.r(n);t("VRzm");var o=t("Kw5r"),i=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{attrs:{id:"app"}},[t("Header"),t("section",{staticClass:"page"},[t("router-view")],1),t("Footer")],1)},a=[],s=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("header",{staticClass:"header",class:{hidden:e.isHidden}},[t("router-link",{staticClass:"title",attrs:{to:{name:"index"}}},[e._v("kpat.io")])],1)},r=[],l=(t("f3/d"),{name:"Header",computed:{isHidden:function(){return"index"!==this.$route.name}}}),c=l,p=(t("mdYu"),t("KHd+")),h=Object(p["a"])(c,s,r,!1,null,"68d08845",null),d=h.exports,u=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("footer",{staticClass:"footer"},[t("router-link",{attrs:{to:{name:"index"}}},[e._v("kpat.io")])],1)},m=[],g={name:"Footer"},f=g,b=(t("KHRh"),Object(p["a"])(f,u,m,!1,null,"0871370c",null)),y=b.exports,w={name:"app",components:{Header:d,Footer:y}},v=w,k=(t("nNx0"),Object(p["a"])(v,i,a,!1,null,null,null)),T=k.exports,x=t("jE9Z"),I=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("section",e._l(e.articles,function(e,n){return t("Preview",{key:n,attrs:{title:e.name}})}))},D=[],S=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"preview",class:{small:e.small}},[t("router-link",{attrs:{to:{name:"detail",params:{title:e.title}}}},[t("span",{staticClass:"next"},[e._v("suggestion")]),t("Post",{staticClass:"post",attrs:{title:e.title}}),t("div",{staticClass:"after"},[t("button",{staticClass:"button"},[e._v("Continue Reading")])])],1),t("hr",{staticClass:"all"})],1)},C=[],P=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("main",[t("article",{ref:"post",staticClass:"post",domProps:{innerHTML:e._s(e.articleLookup(e.title).content)}}),e.error?t("p",[e._v("Couldn't find the article :-(")]):e._e()])},A=[],q=(t("rGqo"),t("yT7P")),E=t("FIf5"),j=t.n(E),_=t("L2JU"),R=(t("jaj/"),t("cFwv"),{name:"Post",props:["title"],data:function(){return{article:"",error:!1}},mounted:function(){this.refreshSyntax()},computed:Object(q["a"])({},Object(_["b"])(["articleLookup"])),methods:{refreshSyntax:function(){this.$refs.post.querySelectorAll("pre > code").forEach(function(e){j.a.highlightBlock(e)})}}}),F=R,L=(t("eTgM"),Object(p["a"])(F,P,A,!1,null,null,null)),W=L.exports,N={name:"Preview",props:["title","small"],components:{Post:W}},O=N,G=(t("uXj7"),Object(p["a"])(O,S,C,!1,null,"62da0c2a",null)),V=G.exports,M={name:"Index",computed:Object(_["b"])(["articles"]),components:{Preview:V}},$=M,H=(t("IajB"),Object(p["a"])($,I,D,!1,null,"57d44152",null)),B=H.exports,K=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("section",[t("Post",{key:e.title,attrs:{title:e.title}}),t("hr",{staticClass:"all"}),t("Preview",{key:e.next,attrs:{title:e.next,small:"true"}})],1)},Y=[],z={props:["title"],name:"Detail",components:{Post:W,Preview:V},computed:Object(q["a"])({},Object(_["b"])(["nextArticle"]),{next:function(){return this.nextArticle(this.title).name}})},J=z,U=(t("0bEL"),Object(p["a"])(J,K,Y,!1,null,"2dcd9926",null)),X=U.exports;o["a"].use(x["a"]);var Z=new x["a"]({mode:"history",routes:[{path:"/",name:"index",component:B},{path:"/post/:title",name:"detail",component:X,props:!0}],scrollBehavior:function(){return{x:0,y:0}}}),Q=(t("INYr"),t("dRSK"),t("fi9V"));o["a"].use(_["a"]);var ee=new _["a"].Store({state:{articles:Q},getters:{articles:function(e){return e.articles},articleLookup:function(e){return function(n){return e.articles.find(function(e){return e.name===n})}},nextArticle:function(e){return function(n){var t=e.articles,o=t.findIndex(function(e){return e.name===n});return t[(o+1)%t.length]}}},mutations:{},actions:{}});o["a"].config.productionTip=!1,new o["a"]({el:"#app",router:Z,store:ee,components:{App:T},render:function(e){return e(T)},template:"<App/>"})},Yb3g:function(e,n,t){},dI4h:function(e,n,t){},dsyQ:function(e,n,t){},dtHW:function(e,n,t){},eTgM:function(e,n,t){"use strict";var o=t("f4zm"),i=t.n(o);i.a},f4zm:function(e,n,t){},fi9V:function(e){e.exports=[{name:"test-engineering",date:"2018-07-08",content:"<date>July 8, 2018</date>\n<h2>Test Engineering</h2>\n<p>\n    Writing tests is a common practice, especially for firms that leverage\n    continuous delivery. With this article I'd like to explain some \n    methods that can be used to generate test cases. The following\n    methods are covered in the scope of the post\n</p>\n<ul>\n    <li>Equivalence partitioning and boundary values</li>\n    <li>State transitions</li>\n    <li>Path testing</li>\n</ul>\n<p>\n    Let's dive into the details of each method.\n</p>\n\n<h3>Partitions and Boundaries</h3>\n<p>\n    Similar to mathematical functions, in programming a function maps\n    inputs from a given domain <b>X</b> to a codomain <b>Y</b>. \n    <b>Equivalence Partitioning</b> (EP) is a method to split the domain \n    <b>X</b> into multiple partitions that exhibit the same behaviour.\n    For each partition a single test case is created, thus creating a\n    kind of <em>Partition Coverage</em>.\n</p>\n<p>\n    An example will shed light on the methodology\n</p>\n<pre><code class=\"go\">func CalcPrice(amount uint) {\n    if amount > 100 {\n        return 10\n    }\n\n    if amount > 50 {\n        return 11\n    }\n\n    if amount > 10 {\n        return 15\n    }\n\n    return 20\n}</code></pre>\n<p>\n    There are four partitions to this <b>CalcPrice</b> function\n</p>\n<ol>\n    <li>The range from 100 to infinity <b>(100, &infin;)</b></li>\n    <li>The range 50 to 100 <b>(50, 100]</b></li>\n    <li>The range 10 to 50 <b>(10, 50]</b></li>\n    <li>The range up to 10 <b>[0, 10]</b></li>\n</ol>\n<p>\n    EP now recommends to cover each of the partitions in one test.\n    <b>Boundary Value Analysis</b> (BVA) extends this definition\n    to also include the lower and upper values of the boundaries.\n    The reasoning behind this is simple. There are usually a lot\n    of issues with the boundaries, since the ranges can either\n    be openend or closed on either side.\n</p>\n<p>\n    BVA adds another 8 tests to the list: <em>UINT_MAX, 101, \n    100, 51, 50, 11, 10, 0</em>. Together with EP that results\n    in 12 tests, giving a reasonable coverage.\n</p>\n\n<h3>State Transitions</h3>\n<p>\n    Virtually all systems that we design contain some kind of\n    state and necessarily also some mechanism to alter that state. \n    In state trainsition analysis, all possible states of a single \n    component and their transitions from on to another are graphed.\n</p>\n<p>\n    Let's take the example of a traffic light. There are four\n    different states: <b>Yellow Flahsing</b>, <b>Red</b>, \n    <b>Yellow</b>, <b>Green</b>. <b>Yellow Flashing</b> depicts the\n    base state. Together with these states, there are six allowed transitions:\n</p>\n<ul>\n    <li><b>Yellow Flashing</b> &rarr; <b>Red</b></li>\n    <li><b>Red</b> &rarr; <b>Yellow</b></li>\n    <li><b>Yellow</b> &rarr; <b>Green</b></li>\n    <li><b>Green</b> &rarr; <b>Yellow</b></li>\n    <li><b>Yellow</b> &rarr; <b>Red</b></li>\n    <li><b>Red</b> &rarr; <b>Yellow Flashing</b></li>\n</ul>\n<p>\n    When testing state transitions, there should be tests for \n    each transition, be it valid or invalid. The tests are to assert\n    that no illegal transitions take place and that the system\n    behaves according to the graph.\n</p>\n\n<h3>Path Testing</h3>\n<p>\n    <b>Path testsing</b> is one possibility of making sure that the code we've\n    written works as expected. Let's first have a look on how we can measure\n    the completeness of our tests.\n</p>\n<p>\n    A measurement of the code that has been tested\n    is commonly referred to as <b>Code Coverage</b>.\n    There are three different strategies of analyzing code coverage\n</p>\n<ul>\n    <li>\n        <b>Statement Coverage</b> - percentage of statements reached\n    </li>\n    <li>\n        <b>Branch Coverage</b> - percentage of conditional decisions reached \n    </li>\n    <li>\n        <b>Path Coverage</b> - percentage of paths covered\n    </li>\n</ul>\n<p>\n    The further down we go in the list, the more tests there are to write.\n    This simple example illustrates the three types\n</p>\n<pre><code class=\"go\">func CalculateValue(withVat bool, amount uint) {\n    var calcPrice\n\n    if amount > 10 {\n        calcPrice = 50\n    } else if amount > 20 {\n        // Unreachable code\n    } else {\n        calcPrice = 55\n    }\n\n    if withVat {\n        calcPrice *= 1.08\n    }\n\n    return amount * calcPrice\n}\n</code></pre>\n<p>\n    Now <em>100% statement coverage</em> would require merely <em>two tests</em>.\n    One for <b>amount &gt; 10</b> and one for <b>amount &lt; 10</b>, while \n    keeping <b>withVat = true</b> for both.\n    These two tests effectively call <em>100%</em> of the statements.\n</p>\n<p>\n    <em>100% branch coverage</em> requires that possible scenario in a \n    branch is tested at least once. We'd also write <em>two tests</em>. One for\n    <b>amount &gt; 10 &amp; withVat = true</b> and one <b>amount &lt; 10 \n    &amp; withVat = false</b>. We'd also notice that the branch \n    <b>amount > 20</b> in the above code can never be reached, thus \n    potentially finding a bug.\n</p>\n<p>\n    <em>100% path coverage</em> is more exact and thus requires more\n    testing effort. For this scenario we'd need <em>four tests</em> \n    (ignoring the <b>amount &gt; 20</b> problem we've already detected)\n</p>\n<ol>\n    <li><b>amount &gt; 10 &amp; withVat = true</b></li>\n    <li><b>amount &lt; 10 &amp; withVat = true</b></li>\n    <li><b>amount &gt; 10 &amp; withVat = false</b></li>\n    <li><b>amount &lt; 10 &amp; withVat = false</b></li>\n</ol>\n<p>\n    The measurement of path coverage is thus the most thorough and \n    accurate, yet also the most costly to reach.\n</p>\n<p>\n    <b>Path testing</b> is the practice of reaching a high <b>path coverage</b>.\n    In this methodology, tests are extracted according to all the paths that \n    lead through our code.\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    The three methods above should give the reader a starting point\n    of how tests can be engineered. The list is by no means complete.\n</p>"},{name:"testable-code",date:"2018-07-03",content:"<date>July 3, 2018</date>\n<h2>Testable Code</h2>\n<p>\n    Testing has quickly become a standard in the software industry. Writing\n    testable code is quite simple when following a few simple guidelines. This \n    post aims at providing you with a framework for tackling that issue.\n</p>\n<p>\n    The <b>SOLID</b> principle plays a big role when it comes to writing\n    testable code. It is an important cornerstone for writing high quality and \n    maintainable code. Together with <b>Dependency Injection</b> it lays the\n    foundation of testability. The following principles comprise the base recipe\n</p>\n<ul>\n    <li><b>S</b>ingle Responsibility</li>\n    <li><b>O</b>pen-Closed</li>\n    <li><b>L</b>iskov Substitution</li>\n    <li><b>I</b>nterface Segregation</li>\n    <li><b>D</b>ependency Inversion</li>\n    <li>Dependency Injection</li>\n</ul>\n<p>\n    The following sections explain the principles and how they apply to testability,\n    together with examples.\n</p>\n\n<h3>Single Responsibility</h3>\n<p>\n    The <b>Single Responsibility Principle</b> (SRP) states that every component of a system \n    should have one and only one responsibility. Or as Robert C. Martin elegantly phrases it\n</p>\n<blockquote>A class should have only one reason to change</blockquote>\n<p>\n    An example of this could be \n</p>\n<pre><code class=\"go\">package export\n\ntype ExportSvc interface {\n    Serialize(interface{}) (string, err)\n    WriteToFile(string) err\n}\n\ntype Exp struct {}\n\n//Exp -> extends interface</code></pre>\n<p>\n    The <b>Exp</b> struct violates the SRP, because there are two scenarios that require a change in code.\n    Number one is the serialization mechanism. Maybe our API will accept json instead of yaml.\n    And number two is the access to the file system. Supposedly we switch from <em>write to disk</em>\n    to <em>Amazon S3</em>.\n</p>\n<p>\n    Increasingly complex systems to design and maintain imply an increasing number of \n    reasons for change. SRP makes sure that these changes have a small footprint on \n    our codebase. Increased testability of our code is thus reached by narrowing the \n    scope and therefore the complexity of both our tests and their subjects.\n</p>\n\n<h3>Open-Closed</h3>\n<p>\n    The <b>Open-Closed</b> principle (OCP) states, according to it's creator, Bertran Meyer\n</p>\n<blockquote>\n    Software entities (classes, modules, functions, etc.) should be open for extension, \n    but closed for modification\n</blockquote>\n<p>\n    Being <b>open</b> for extension means that the behaviour of a given component can be \n    extended. In other words, the behaviour is not set in stone or written in such a manner \n    that extending functionality infers copying of code.\n</p>\n<p>\n    When a component is called <b>closed</b> for modification it means that the public API of \n    this component is fixed. Furthermore, no changes to the code are to be made.\n</p>\n<p>\n    Typically violations of this principle are verbose switch case statements or if-elseif structures. \n    The following example illustrates a clear violation\n</p>\n<pre><code class=\"go\">package main\n\ntype Product struct{\n    Type string\n    //...\n}\n\ntype PriceSvc struct{}\n\nfunc (_ *PriceSvc) GetVAT(p *Product) uint {\n    switch p.Type {\n    case 'food':\n        return 70\n    case 'other':\n        return 0\n    default:\n        return 80\n    }\n}</code></pre>\n<p>\n    Immagine this code is inside of a library you're using. Now in order to <em>extend</em> the behaviour of\n    the <b>GetVAT</b> method by another type, let's say <b>'furniture'</b>, the programmer has to either modify\n    the original code or overwrite it completely. When overwriting the code she potentially also has to write \n    test cases for each scenario.\n</p>\n<p>\n    The example could be fixed by introducing a simple mapping table \n    <b>type -> VAT</b>. When adding new product types, another entry\n    can be inserted to this table, leaving it open for extension. Furthermore, \n    instead of writing a test case per product type, a single more generic\n    test can be written instead.\n</p>\n<p>\n    Software systems are subject to a good deal of change. The <b>OCP</b>, much like the SRP, helps\n    us to reduce the impact change has on our system. In practice the two principles go hand in hand, since\n    having complex paths in your code, a violation of OCP, normally also implies a violation of the SRP.\n</p>\n\n<h3>Liskov Substitution</h3>\n<p>\n    The <b>Liskov Substitution Principle</b> (LSP) states that if a type <b>S</b> is a subtype\n    of type <b>T</b>, then <b>S</b> must include all the same behaviours as <b>T</b>. This has\n    profound implications on inheritance in object oriented programming languages. The \n    principle infers that function signatures stay equivalent in subtypes, as well as \n    exceptions that are thrown.\n</p>\n<p>\n    <b>LSP</b> has way more implications, that won't be subject of this post. It is a broad \n    topic that warrants an article on it's own.\n</p>\n\n<h3>Interface Segregation</h3>\n<p>\n    According to the <b>Interface Segregation Principle</b> (ISP), clients ought not be \n    forced to depend on unused methods. In other words, keep your interfaces small and\n    segregated.\n</p>\n<p>\n    Violations of this principle are numerous and most often also infer a \n    transgression against the SRP. Here the same example as for the SRP\n</p>\n<pre><code class=\"go\">package main\n\ntype ExportSvc interface {\n    Serialize(interface{}) (string, err)\n    WriteToFile(string) err\n}</code></pre>\n<p>\n    A possible violation of this is that a client might only need to depend \n    on one the <b>Serialize</b> function. Using this interface, she's also \n    aware of the <b>WriteToFile</b> function which creates an unnecessary \n    dependency. Splitting the interface into two separate interafaces would\n    solve the violation, yet still violates the SRP.\n</p>\n<p>\n    When writing tests, ISP enables us to create smaller mock objects of\n    the dependencies we're injecting. Thus decreasing the lines of code\n    and the complexity.\n</p>\n\n<h3>Dependency Inversion</h3>\n<p>\n    Many programmers hardwire business layers with the utility layers,\n    making it harder to replace single components in a system. The \n    <b>Dependency Inversion Principle</b> (DIP) is a way to solve that\n    problem. It states\n</p>\n<blockquote>\n    High level components should not depend upon low level components. Both should depend upon abstractions.\n</blockquote>\n<p>\n    This basically means that instead of leveraging concrete classes, we\n    should always rely on interfaces. Since our modules are loosely coupled,\n    the impact of this inversion principle is kept relatively low.\n    Go, compared to other programming languages, makes it easy to \n    comply with the DIP, since interfaces are implemented implicitly.\n</p>\n<p>\n    Examples of this principles are trivial and hence omitted. When testing,\n    this principle allows us to inject minimalistic classes that correspond\n    to the interface, rather than laboriously overwriting functionality\n    and overloading our component tests.\n</p>\n\n<h3>Dependency Injection</h3>\n<p>\n    <b>Dependency Injection</b> (DI) is not part of the <b>SOLID</b> principles, yet\n    it has a significant impact on our design, and hence also our tests. Following\n    DI, the programmer injects the dependencies, rather than instantiating them\n    on the fly. This leads to the encapsulation of the construction logic, as well\n    as the flexible replacability of the dependencies.\n</p>\n<p>\n    The following example shows a violation of the DI practice\n</p>\n<pre><code class=\"go\">type Dep1 interface{}\ntype Dep2 interface{}\n\ntype Svc struct {\n    dep1 *Dep1\n    dep2 *Dep2\n}\n\nfunc NewSvc() *Svc {\n    return &amp;Svc{\n        dep1: &amp;Dep1{}, \n        dep2: &amp;Dep2{},\n    }\n}\n</code></pre>\n<p>\n    If one were to replace, for example, <b>Dep1</b> with another implementation,\n    the construction code would have to be altered. To satisfy DI we do the following\n</p>\n<pre><code class=\"go\">type Dep1 interface{}\ntype Dep2 interface{}\n\ntype Svc struct {\n    dep1 *Dep1\n    dep2 *Dep2\n}\n\nfunc NewSvc(dep1 *Dep1, dep2 *Dep2) *Svc {\n    return &amp;Svc{\n        dep1: dep1, \n        dep2: dep2,\n    }\n}\n</code></pre>\n<p>\n    This subtle change empowers the caller to provide the dependencies. Together with\n    the DIP, this leads to the complete independence of the implementation of a class.\n    Take a second to appreciate the value we've just gained.\n</p>\n<p>\n    To create unit tests, we have to remove all the dependencies from our component\n    to be able to test in isolation. DI, together with the DIP, allows us to do \n    exactly that, thus it is vital to our design.\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    The above stated principles all aim at reducing effort and complexity to write \n    tests, as well as to maintain them. Here in short a few best practices to follow\n</p>\n<ul>\n    <li>Follow the five <b>SOLID</b> principles</li>\n    <li>Avoid global variables and functions</li>\n    <li>Inject dependencies, instead of constructing them or leveraging static or global methods</li>\n</ul>\n<p>\n    All these principles take time to adjust to, yet they ultimately lead to \n    higher quality systems, making them a good investment.\n</p>"},{name:"cicd-pipeline",date:"2018-06-22",content:'<date>June 22, 2018</date>\n<h2>CI/CD Pipeline</h2>\n<p>\n    <b>Continuous Integration</b> (CI) and <b>Continuous Delivery</b> (CD) are essential to\n    fast delivery of software. Getting ramped up can be quite cumbersome. This\n    post aims at providing a jump start.\n</p>\n<p>\n    First things first, we have to define the two terms\n</p>\n<blockquote>\n    <b>Continuous Integration</b> is a practice of automatically running tests, inspecting code, and building project artifacts to create a continuous feedback loop about the state of the project. It\'s a verification that the changes can be released without causing a hassle.\n</blockquote>\n<blockquote>\n    <b>Continuous Delivery</b> is a practice of continuously creating working and reliable software increments (without deployment)\n</blockquote>\n<p>\n    Let\'s start building.\n</p>\n<h3>The Pipeline</h3>\n<p>\n    Optimally, the pipeline gets triggered after each commit to the VCS to provide developers \n    with instant feedback about the current project status. The following is a non-exhaustive\n    list of steps to consider in a pipeline\n</p>\n<ul>\n    <li>Checkout the project from the VCS</li>\n    <li>Install dependencies</li>\n    <li>Static code testing</li>\n    <li>Dynamic code testing</li>\n    <li>Building the deployment artifact</li>\n    <li>Deployment to a non-production environment</li>\n</ul>\n<p>\n    In addition to checking the quality of the code, these steps also make sure that the \n    process is repeatable and reproducible on a generic environment.\n</p>\n<blockquote>\n    Tip: If one of the steps\n    should fail on the way, it is crucial that the pipeline is aborted and feedback is\n    reported to the developers. A failing pipeline should be the top priority of the\n    development team.\n</blockquote>\n<p>\n    Let\'s go through these steps one by one.\n</p>\n<h3>Checkout &amp; Dependencies</h3>\n<p>\n     Here examples for the first two steps\n</p>\n<pre><code class="bash"># Step one: fetch the code from the repository\n$ git clone ssh://git@example.com/path/to/repo.git\n# for node dependencies:\n$ npm install\n# for golang dependencies:\n$ dep ensure\n</code></pre>\n<p>\n    The important thing to note here is that for checking out the code you need\n    the appropriate access to the repository. It is common practice to issue a\n    access token to the CI server for that purpose. Alternatively, a ssh key can\n    be generated on the CI server and be added to the runner.\n</p>\n\n<h3>Static Code Testing</h3>\n<p>\n    Static properties of the code base can be used as a first quality gate. There are\n    various static code analysis methods\n</p>\n<ul>\n    <li>\n        Linting - Make sure that the source code conforms to the standard and doesn\'t \n        raise any compiler problems\n    </li>\n    <li>Mess detection - Measure how "messy" the code is</li>\n    <li>Dependency analysis - Ensure that the code follows <em>loose coupling</em></li>\n    <li>Security checking - Detect security vulnerabilities early on</li>\n</ul>\n<p>\n    Golang for example features the <b>golint</b> command\n</p>\n<pre><code class="bash">$ golint $(go list ./... | grep -v /vendor/)\n</code></pre>\n<p>\n    This command returns a non-zero exit code when there are issues with the code base,\n    thus aborting the pipeline if the code doesn\'t conform to the defined guidelines.\n</p>\n\n<h3>Dynamic Testing</h3>\n<p>\n    In contrast to static tests, dynamic tests provide feedback about the\n    runtime functionality of the code base.\n</p>\n<blockquote>\n    Tip: In order to be effective, dynamic tests should run in under 10 minutes. The\n    feedback loop should be kept short. Long running tests should be scheduled separately\n</blockquote>\n<p>\n    Golang includes the <b>test</b> subcommand. It is executed as such\n</p>\n<pre><code class="bash">$ go test $(go list ./... | grep -v /vendor/)</code></pre>\n<p>\n    Similar to the linting process, this command returns a non-zero exit code upon\n    failure, printing out the errors into <b>STDERR</b>.\n</p>\n<blockquote>\n    Tip: Developers should have access to the pipeline logs\n</blockquote>\n\n<h3>Building the Artifact for Deployment</h3>\n<p>\n    Different programming environments have different build artifacts. For golang\n    this is a compiled static binary, for PHP or python this could be zipped source\n    code with all dependencies included. Nowadays, the artifact most commonly is\n    a tagged docker image.\n</p>\n<blockquote>\n    Tip: The build step should not be executed on the production system. This way \n    the production system is not exposed to development tooling vulnerabilities.\n</blockquote>\n<p>\n    Golang features the <b>go build</b> command. This squashes the code, together\n    with the dependencies, into a single static binary. Here\'s an example\n</p>\n<pre><code class="bash">$ go build -ldflags "-extldflags \'-static\'" -o bin/server.bin</code></pre>\n<p>\n    This builds the go binary for the same execution environment as the CI server.\n    In a second step, this binary can be included into a docker image\n</p>\n<pre><code class="docker">FROM alpine:3.8\nWORKDIR /app\nADD bin/server.bin server.bin\nCMD ./server.bin</code></pre>\n<p>\n    Which can then be built, tagged, and deployed to the appropriate \n    environment\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    The following is an incomplete list of best practices to consider when \n    creating your own pipeline.\n</p>\n<ul>\n    <li>Trigger the pipeline with every commit</li>\n    <li>\n        Feedback from the pipeline should be fast\n        <ul>\n            <li>Fail early - abort the pipeline if a single stage fails</li>\n            <li>Consider 10 minutes as a glass ceiling</li>\n            <li>If you have test that take too long, consider optimizing or running these tests seperately</li>\n        </ul>\n    </li>\n    <li>If the pipeline fails, it\'s the utmost priority of the team to fix it</li>\n    <li>The developers must have access to the pipeline logs</li>\n    <li>Build artifacts on the CI server instead of the production system</li>\n    <li>Keep the deployment lean and fast</li>\n</ul>'},{name:"kubernetes-core",date:"2018-06-15",content:'<date>June 15, 2018</date>\n<h2>Kubernetes Basics</h2>\n<p>\n    Container orchestration is quickly becoming a defacto standard among tech firms.\n    As software requirements become more and more complex and service outages are \n    increasingly expensive, the systems we build have to scale up seamlessly and be \n    highly available.\n</p>\n<p>\n    Kubernetes or <b>k8s</b> is one possible tool to fulfill that job. In it\'s own\n    words:\n</p>\n<blockquote>\n    Kubernetes is an open-source system for automating deployment, scaling, and \n    management of containerized applications.\n</blockquote>\n<p>\n    At the core of k8s there are a few abstractions that we have a look\n    at to get started with orchestrating and automating our containers.\n</p>\n<ul>\n    <li>Pods<sup>1</sup></li>\n    <li>Deployments<sup>2</sup></li>\n    <li>Services<sup>3</sup></li>\n    <li>Ingress<sup>4</sup></li>\n</ul>\n<p>\n    These concepts allow us to engineer products that are resilient\n    and self healing in a concise manner.\n</p>\n\n<h3>Manifests</h3>\n<p>\n    The resources necessary for k8s are handled by <b>kubectl</b> - either manually \n    or via manifest files. For automation purposes manifest files are best \n    practice. All Manifest files follow the same structure and can be interpreted\n    in multiple formats. Here an example in yaml\n</p>\n<pre><code class="less">apiVersion: v1\nkind: Pod\nmetadata:\n    name: podname\n    namespace: ns\n    labels:\n        key1: value1\n        key2: value2\nspec:\n    ...\n</code></pre>\n<p>\n    The following base elements are specified for each manifest file\n</p>\n<ul>\n    <li><b>apiVersion</b> - The version of the k8s API</li>\n    <li><b>kind</b> - The type of object that is to be created</li>\n    <li><b>metadata</b> - Metadata including the name, namespace, and labels to identify the resource</li>\n    <li><b>spec</b> - The specification of the object</li>\n</ul>\n<p>\n    This allows us to create and destroy resources within a k8s cluster.\n    Now let\'s have a closer look at the types of resources we can create.\n</p>\n\n<h3>Pods</h3>\n<p>\n    <b>Pods</b> are the smallest unit of scheduling in k8s. They\n    can contain multiple tighly coupled containers, that share all resources.\n    This enables containers in the same pod to communicate as if they\n    are colocated on the same logical host. This colocation imples the access\n    to the same port ranges, memory, and file access.\n</p>\n<p>\n    The following example describes a pod including a single nginx container\n    exposing port 80 to the other pods.\n</p>\n<pre><code class="less">apiVersion: v1\nkind: Pod\nmetadata:\n    name: nginx\n    labels:\n        app: srv\nspec:\n    containers:\n    - name: nginx\n      image: nginx:1.7.9\n      ports:\n      - containerPort: 80\n</code></pre>\n<p>\n    Manually deploying pods to k8s clusters is not common practice. <b>Deployments</b> \n    that create <b>ReplicationControllers</b>, which make sure that there is a certain \n    number of pods running at a certain time, handle the life cycle of pods.\n</p>\n\n<h3>Deployments</h3>\n<p>\n    <b>Deployments</b> exist to regulate the creation, destruction, and life cycle \n    management of pods. A deployment depicts the target state of the application. \n    If a new version of an application gets deployed to a k8s cluster, deployments \n    take care of the bureaucracy of spinning up new pods and fading out old ones \n    without affecting uptime.\n</p>\n<p>\n    The following deployment spins up 3 replicas of a nginx container\n</p>\n<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n    name: srv-deploy\n    labels:\n        app: srv\nspec:\n    replicas: 3\n    selector:\n        matchLabels:\n            app: srv\n    template:\n        metadata:\n            labels:\n                app: srv\n        spec:\n            containers:\n            - name: nginx\n              image: nginx:1.7.9\n              ports:\n              - containerPort: 80\n</code></pre>\n<p>\n    The <b>template</b> field of the deployment specification follows the exact syntax of \n    a pod definition. If the manifest is changed and applied to the cluster, in the background \n    k8s spins up another deployment, waiting for the containers to be available, then \n    gradually removes the old pods.\n</p>\n<p>\n    Up and down scaling of the replicas is handled by a <b>ReplicationController</b> (RC). It\'s\n    job is to make sure that a specified number of replicas are up and\n    running at any given moment. If a pod crashes or becomes unresponsive, the RC will terminate\n    the dying pod and spawn another one as a replacement.\n</p>\n<p>\n    When creating multiple replicas of a pod, we need an abstraction to handle access in a \n    unified way. <b>Services</b> provide exactly that abstraction.\n</p>\n\n<h3>Services</h3>\n<p>\n    <b>Services</b> tie a group of pods together to a unified endpoint by using\n    label selectors. They also represent addressable named units within a \n    namespace.\n</p>\n<p>\n    The following manifest shows a service that selects all pods with the \n    <b>app: srv</b> label and then exposes port 80.\n</p>\n<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n    name: somesvc\nspec:\n    selector:\n        app: srv\n    ports:\n    - protocol: TCP\n      port: 80\n</code></pre>\n<p>\n    The service we created is limited to the local k8s network\n    and currently isn\'t exposed via a public IP. To expose services\n    to the internet we create a resource called <b>ingress</b>.\n</p>\n\n<h3>Ingress</h3>\n<p>\n    To fulfill the promise of <em>multitenancy</em>, a k8s cluster needs to\n    be able to route to multiple endpoints independently. This is where <b>ingress</b> \n    comes in, as the name already implies ingress has the ability of reverse\n    proxying from the internet into the cluster. \n</p>\n<p>\n    The following example routes <b>s1.example.com</b> to the service \n    <b>s1</b> and <b>s2.example.com</b> to <b>s2</b>.\n</p>\n<pre><code class="less">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n    name: test\nspec:\n    rules:\n    - host: s1.example.com\n    http:\n        paths:\n        - backend:\n            serviceName: s1\n            servicePort: 80\n    - host: s2.example.com\n    http:\n        paths:\n        - backend:\n            serviceName: s2\n            servicePort: 80\n</code></pre>\n<p>\n    Ingress, being the primary endpoint for any incoming connection, \n    also supports <em>TLS</em>.\n</p>\n<p>\n    Now we have a way of deploying our services, scaling them independently, \n    and routing to them from the internet. This covers the very basics of k8s.\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    Kubernetes is a powerful orchestration tool. With the above mentioned resources we can\n    already automate a service to run in our cluster. \n</p>\n<p>\n    Here a few best practices to adhere by when dealing with k8s resources\n</p>\n<ul>\n    <li>Never deploy pods on their own - always use <b>deployments</b> to manage their lifecycle</li>\n    <li>\n        Use <em>one container per pod</em> - this avoids port collisions and keeps your \n        containers independently scalable\n    </li>\n    <li>Only use the <b>latest</b> tag for internal docker images, never for external ones</li>\n    <li>\n        Create services before deployments are created\n        <ul>\n            <li>Deployments take some time to ramp up</li>\n            <li>Services are created instantly</li>\n        </ul>\n    </li>\n    <li>Use <b>ingress</b> to expose services to the outside world instead of <b>services</b></li>\n    <li>Include the orchestration logic in the service\'s version control system</li>\n    <li>Create a CICD pipeline that deploys to your cluster in an automated fashion</li>\n</ul>\n<p>\n    There are additional concepts of vital importance to a k8s cluster. The\n    following is a non-exhaustive list of additional <em>kinds</em> to explore\n</p>\n<ul>\n    <li>\n        <b>Namespace</b> - Used, among other things, to avoid naming conflicts when \n        dealing with multiple environments\n    </li>\n    <li>\n        <b>ConfigMap</b> and <b>Secret</b> - Introduce potentially shared static configuration to the pods\n    </li>\n    <li>\n        <b>StorageClass</b> and <b>PersistentVolumeClaim</b> - Used to share volatile data\n        among pods\n    </li>\n    <li>\n        <b>NetworkPolicy</b> - Used to regulate egress and ingress access to certain nodes \n        and services\n    </li>\n    <li>\n        <b>Job</b> and <b>CronJob</b> - Used to run single or periodic jobs on a k8s cluster\n    </li>\n</ul>\n<p>\n    For more information, refer to the k8s documentation<sup>5</sup>\n</p>\n<hr>\n<h3>References</h3>\n<ol class="references">\n    <li>\n        <a target="_blank" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">\n            Kubernetes resources on <b>Pods</b>\n        </a>\n    </li>\n    <li>\n        <a target="_blank" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">\n            Kubernetes resources on <b>Deployments</b>\n        </a>\n    </li>\n    <li>\n        <a target="_blank" href="https://kubernetes.io/docs/concepts/services-networking/service/">\n            Kubernetes resources on <b>Services</b>\n        </a>\n    </li>\n    <li>\n        <a target="_blank" href="https://kubernetes.io/docs/concepts/services-networking/ingress/">\n            Kubernetes resources on <b>Ingress</b>\n        </a>\n    </li>\n    <li>\n        <a target="_blank" href="https://kubernetes.io/docs/home/">\n            Kubernetes documentation\n        </a>\n    </li>\n</ol>'},{name:"error-propagation",date:"2018-06-09",content:'<date>June 9, 2018</date>\n<h2>Go Error Propagation</h2>\n<p>\n    Error handling is a vital part of any programming language. There\'s \n    any number of things that can go wrong if you interact with the outside \n    world. A file can be missing or corrupt, an endpoint temporarily unreachable,\n    a database server down, etc. Things can go wrong everywhere.\n    Now in order to keep the systems we work on maintainable and user friendly,\n    we have to handle these errors appropriately.\n</p>\n<p>\n    Different languages offer different mechanisms for handling errors.\n    Most modern programming languages, for example, include a feature called \n    <b>exceptions</b> as a convenient\n    way to propagate errors through <b>multiple</b>\n    layers. This feature is missing in Go - and that\'s on purpose.\n</p>\n<p>\n    In the following sections we\'ll explore some common methods for avoiding\n    error handling. I like call these <b>anti-patterns</b> or <b>"don\'ts"</b>\n</p>\n<h3>Method 1: Ignore</h3>\n<p>\n    The first anti-pattern in error handling - and this is <b>not</b> limited \n    to go - is ignoring them alltogether. Here is a piece of code that makes excessive\n    use of the underscore (<b>_</b>). The underscore, also known as the \n    <b>blank identifier</b>, is used when calling functions with multiple\n    return values to discard one of these values.\n</p>\n<p>\n    Let\'s have a look at the example\n</p>\n<pre><code>// file: main.go\n\npackage main\n\nimport (\n    "io/ioutil"\n    "log"\n    "net/http"\n)\n\nfunc main() {\n    cont := doWork("google.com")\n\n    log.Println(cont)\n}\n\nfunc doWork(host string) string {\n    client := &amp;http.Client{}\n\n    req, _ := http.NewRequest("GET", host, nil)\n\n    req.Header.Add("Accept", "application/json")\n    req.AddCookie(&amp;http.Cookie{Name: "ID", Value: "1B2EB10C8ADDE70440A2EFBA15C2C6CD"})\n\n    resp, _ := client.Do(req)\n\n    b, _ := ioutil.ReadAll(resp.Body)\n\n    return string(b)\n}</code></pre>\n<p>\n    Looks good enough, right? So there is this <b>doWork</b> function that calls an \n    API endpoint with a cookie, then reads the contents and returns them.\n    Now running this will result in a <b>SIGSEGV</b>, a segmentation fault.\n    Meaning, that one of the errors in the code is not <b>nil</b> and the \n    corresponding unignored value therefore is. \n</p>\n<p>\n    We clearly don\'t want code like this in our production systems. Let\'s try \n    something different.\n</p>\n\n<h3>Method 2: Delegate</h3>\n<p>\n    Since go is <em>annoying</em> and doesn\'t let us propagate the errors to\n    the next layer, we can just try replicate that missing feature ourselves.\n    What if we <b>delegate</b> the error to the calling function? We can just\n    "offshore" the work to the poor fellow who will be interacting with our API.\n</p>\n<p>\n    Let\'s have a peak what that might look like with our example\n</p>\n<pre><code>// file: main.go\n\n// ...\n\nfunc main() {\n    cont, err := doWork("google.com")\n\n    if err != nil {\n        log.Panicln(err)\n    }\n\n    log.Println(cont)\n}\n\nfunc doWork(host string) (string, error) {\n    client := &amp;http.Client{}\n\n    req, err := http.NewRequest("GET", host, nil)\n\n    if err != nil {\n        return "", err\n    }\n\n    req.Header.Add("Accept", "application/json")\n    req.AddCookie(&amp;http.Cookie{Name: "ID", Value: "1B2EB10C8ADDE70440A2EFBA15C2C6CD"})\n\n    resp, err := client.Do(req)\n\n    if err != nil {\n        return "", err\n    }\n\n    b, err := ioutil.ReadAll(resp.Body)\n\n    if err != nil {\n        return "", err\n    }\n\n    return string(b), nil\n}\n</code></pre>\n<p>\n    We\'ve added error delegation inbetween the business logic. The \n    caller now gets a <em>mysterious</em> error message together with a trace\n    that tells her where the error is originating. \n</p>\n<pre><code class="bash">$ go run main.go\npanic: Get google.com: unsupported protocol scheme ""\n</code></pre>\n<p>\n    This is marginally more useful\n    than just crashing, I admit it, yet, not user friendly at all. So how can\n    we improve that?\n</p>\n\n<h3>Improvements</h3>\n<p>\n    Let\'s say Lisa is interacting with our system. Now she\'s getting an error \n    from our API. What Lisa would like to know is\n</p>\n<blockquote>\n    How can I adjust the input value to get rid of the error? What am I doing wrong?\n</blockquote>\n<p>\n    This is a difficult question to answer. What we can easily answer is\n</p>\n<blockquote>\n    What part of the system was I interacting with that produced the error?\n</blockquote>\n<p>\n    Let\'s glance at an example\n</p>\n<pre><code>// file: main.go\n\n// ...\n\nfunc doWork(host string) (string, error) {\n    client := &amp;http.Client{}\n\n    req, err := http.NewRequest("GET", host, nil)\n\n    if err != nil {\n        return "", fmt.Errorf("Failed to create a new request: %v", err)\n    }\n\n    req.Header.Add("Accept", "application/json")\n    req.AddCookie(&amp;http.Cookie{Name: "ID", Value: "1B2EB10C8ADDE70440A2EFBA15C2C6CD"})\n\n    resp, err := client.Do(req)\n\n    if err != nil {\n        return "", fmt.Errorf("Failed to execute the request with host \\"%s\\": %v", host, err)\n    }\n\n    b, err := ioutil.ReadAll(resp.Body)\n\n    if err != nil {\n        return "", fmt.Errorf("Failed to read from request body: %v", err)\n    }\n\n    return string(b), nil\n}\n</code></pre>\n<p>And the corresponding output</p>\n<pre><code class="bash">$ go run main.go\npanic: Failed to execute the request with host "google.com": Get google.com: unsupported protocol scheme ""\n</code></pre>\n<p>\n    Now Lisa knows that we were trying to dispatch the request as the error happened. \n    Together with the trace, I\'d argue, she has a better chance of finding out what\n    changes she has to make to fix her code.\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    There is no magic formula to getting error handling right. We\n    just have consider the poor person interacting with our code.\n    Make it a better experience for them.\n</p>\n<p>\n    Here are a few <em>best practices</em> around error handling. Some of them\n    not covered by the scope of this article.\n</p>\n<ul>\n    <li>Try to give the programmer a hint of where the code is failing</li>\n    <li><b>Always</b> include the trace for internal APIs</li>\n    <li>Hide error information from end users. This might expose a security flaw in your system</li>\n    <li>\n        Try to fail softly. Some errors can be recovered from.\n        <ul>\n            <li>Few errors should render a service unfunctional</li>\n            <li>\n                If, for example, the billing service is unresponsive, simply \n                display a message instead of a internal server error\n            </li>\n        </ul>\n    </li>\n    \n</ul>'},{name:"go-testing",date:"2018-06-08",content:'<date>June 8, 2018</date>\n<h2>TDD with Go</h2>\n<p>\n    This post explains the basics of <b>Test Driven Developmen</b> (TDD) in the <b>Go</b> language.\n    We\'ll start with the basics of TDD and then cover a simple example with the factorial function. \n</p>\n<h3>The Basics of TDD</h3>\n<p>\n    The core idea of TDD is to write tests prior to writing code. In contrast to\n    <b>Test First Development</b>, TDD is an iterative process, which focusses on one test at a time. \n    There are 3 steps to each cycle:\n</p>\n<ul>\n    <li>\n        <span style="color: red">Red</span> - Add a new test for which the code doesn\'t exist yet. \n        Obviously running the test after this phase will result in a failing test.\n    </li>\n    <li>\n        <span style="color: green">Green</span> - Add the minimum amount of code to satisfy the test. \n        At this point all tests should succeed.\n    </li>\n    <li>Refactor - Improve the code without adding functionality</li>\n</ul>\n<p>\n    The cycle is also known as <b>red-green-refactor</b>. After each of these steps, \n    the tests are executed again. This results in good code coverage and incrementally \n    tested code, thus arguably better code quality.\n</p>\n<h3>An Example</h3>\n<p>\n    Let\'s have a look at a concrete example. Mathematical functions are a simple way\n    of getting to know the concept of testing, since they can be modelled without \n    including any dependencies. We pick the factorial function, wich is most commonly \n    denoted by <b>n!</b>. The factorial is a mathematical function which takes the \n    product of all positive integers up to the specified parameter n. Let\'s look at a few \n    examples \n</p>\n<pre><code class="bash"># Definition of factorial\n$ n! = n * (n - 1) * (n - 2) * ... * 2 * 1\n# Alternative definition\n$ n! = n * (n - 1)!\n# 0 is a special value\n$ 0! = 1\n$ 1! = 1\n$ 2! = 2 * 1 = 1\n$ 3! = 3 * 2 * 1 = 6\n$ ...\n$ 10! = 10 * 9 * 8 * ... * 2 * 1 = 3\'628\'800\n</code></pre>\n<p>\n    Without further ado we setup our <b>main.go</b>, which looks as follows\n</p>\n<pre><code class="go">// file: main.go\n\npackage main\n\nfunc main() {\n    // Insert code\n}\n</code></pre>\n<p>\n    And our test file <b>main_test.go</b>\n</p>\n<pre><code class="go">// file: main_test.go\n\npackage main\n\n// Empty for now\n</code></pre>\n<p>\n    Like obedient TDD developers we\'ll start with a test for our \n    <b>factorial</b> function. <b>0! = 1</b> is a special value of this function.\n    Let\'s start there\n</p>\n<pre><code class="go">// file: main_test.go\n\npackage main\n\nimport (\n    "testing"\n)\n\nfunc TestZero(t *testing.T) {\n    res := factorial(0)\n\n    if 1 != res {\n        t.Errorf("Expected 0! to be 1, got %d", res)\n    }\n}\n</code></pre>\n<p>\n    With TDD in mind, we run the tests which returns the anticipated output, an error\n</p>\n<pre><code class="bash">$ go test\n./main_test.go:8: undefined: factorial\nFAIL    test [build failed]\n</code></pre>\n<p>\n    Right now we\'re in the <span style="color: red">red</span> phase. \n    Our tests are failing. The next step is to add as little functionality\n    as possible to make our tests pass. We adapt out <b>main.go</b> as \n    follows\n</p>\n<pre><code class="go">// file: main.go\n// ...\n\nfunc factorial(num int) int {\n    return 0\n}</code></pre>\n<p>\n    Now the code compiles and we don\'t get that compiler error anymore. Yet,\n    our software doesn\'t work as expected yet.\n</p>\n<pre><code class="bash">$ go test\n--- FAIL: TestZero (0.00s)\nmain_test.go:10: Expected 0! to be 1, got 0\nFAIL\nexit status 1\nFAIL    test      0.006s\n</code></pre>\n<p>\n    This step is crucial to TDD, since it assures us that we aren\'t shooting shoot \n    blanks. In other words, our test actually checks the functionality instead of\n    giving us false positives. Let\'s fix that really quick\n</p>\n<pre><code class="go">// file: main.go\n// ...\n\nfunc factorial(num int) int {\n    return 1\n}</code></pre>\n<p>\n    Now we run our test again and see <span stlye="color: green">green</span>.\n</p>\n<pre><code class="bash">$ go test\nPASS\nok      test      0.006s\n</code></pre>\n<p>\n    The code looks quite simple and neat, hence we won\'t go into the refactor step\n    for now. Phew! Let\'s keep the momentum and move to the next value. <b>1! = 1</b> already\n    works - following the protocol, we first make it fail\n</p>\n<pre><code class="go">// file: main_test.go\n// ...\n\nfunc TestOne(t *testing.T) {\n    res := factorial(1)\n    if 0 != res {\n        t.Errorf("Expected 0! to be 1, got %d", res)\n    }\n}\n</code></pre>\n<p>\n    And fix it again\n</p>\n<pre><code class="go">// file: main_test.go\n// ...\n\nfunc TestOne(t *testing.T) {\n    res := factorial(1)\n    if 1 != res {\n        t.Errorf("Expected 0! to be 1, got %d", res)\n    }\n}\n</code></pre>\n<p>\n    For the next value we\'ll add a more generic test case\n</p>\n<pre><code class="go">// file: main_test.go\n// ...\n\nfunc TestN(t *testing.T) {\n    var prov = []struct {\n        n   int\n        exp int\n    }{\n        {2, 2},\n    }\n\n    for _, tt := range prov {\n        act := factorial(tt.n)\n\n        if act != tt.exp {\n            t.Errorf("Expected %d! to be %d, got %d", tt.n, tt.exp, act)\n        }\n    }\n}\n</code></pre>\n<p>\n    Which fails. Now the corresponding functionality\n</p>\n<pre><code class="go">// file: main.go\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n\n    return 2\n}</code></pre>\n<p>\n    Fine, we\'ll stop with the constants now. Let\'s implement our function\n    recursively as in the second definition <b>n! = n * (n - 1)!</b>. We can break\n    the current implementation with the test for <b>n = 3</b>. The test can now\n    be extended as such\n</p>\n<pre><code class="go">// file: main_test.go\n// ...\n\nfunc TestN(t *testing.T) {\n    var prov = []struct {\n        n   int\n        exp int\n    }{\n        {2, 2},\n        {3, 6}, // We added this\n    }\n    for _, tt := range prov {\n        act := factorial(tt.n)\n\n        if act != tt.exp {\n            t.Errorf("Expected %d! to be %d, got %d", tt.n, tt.exp, act)\n        }\n    }\n}\n</code></pre>\n<p><span style="color: red">Red</span>. Now for the actual code</p>\n<pre><code class="go">// file: main.go\nfunc factorial(num int) int {\n    if num &lt;= 1 {\n        return 1\n    }\n\n    return num * factorial(num-1)\n}\n</code></pre>\n<p>\n    And so on. I think you get the point\n</p>\n\n<h3>Conclusion</h3>\n<p>\n    <b>TDD</b> enables developers to achieve a <b>high test coverage</b> quickly\n    and be more aware of what testable code looks like. It\'s a great way\n    for <em>getting used to testing</em>.\n</p>'},{name:"gin-testing",date:"2018-06-08",content:'<date>June 8, 2018</date>\n<h2>Testing with Gin</h2>\n<p>\n    Cheers! This blog post is about writing integration tests for a Gin \n    framework based application. Let\'s dive right in to the basic setup<sup>1</sup>.\n</p>\n<pre><code>// file: main.go\n\npackage main\n\nimport "github.com/gin-gonic/gin"\n\nfunc main() {\n    r := gin.Default()\n\n    // register the ping endpoint\n    r.GET("/ping", pingEndpoint)\n\n    r.Run()\n}\n\nfunc pingEndpoint(c *gin.Context) {\n    c.JSON(200, gin.H{\n        "message": "pong",\n    })\n}</code></pre>\n<p>\n    This returns a message on the endpoint <b>/ping</b> with the content\n</p>\n<pre><code class="bash">$ curl http://localhost:8080/ping\n{"message": "pong"}\n</code></pre>\n<p>\n    All other endpoints return a <b>404 error</b>. In order to prepare for integration \n    tests, the first thing to do with this is a small refactoring.\n    The server setup can be extracted out of the main function context as such:\n</p>\n<pre><code>// file: main.go\n\npackage main\n\nimport "github.com/gin-gonic/gin"\n\nfunc main() {\n    setupServer().Run()\n}\n\n// The engine with all endpoints is now extracted from the main function\nfunc setupServer() *gin.Engine {\n    r := gin.Default()\n\n    r.GET("/ping", pingEndpoint)\n\n    return r\n}\n\nfunc pingEndpoint(c *gin.Context) {\n    c.JSON(200, gin.H{\n        "message": "pong",\n    })\n}</code></pre>\n<p>\n    Once the extraction is performed, <b>main_test.go</b> can be set up. The <b>httptest</b>\n    package, that\'s already baked into golang, was designed for this very use case. \n    Fortunately the Gin framework developers have maintained \n    compatibility with the standard http interfaces and can thus be used seamlessly in conjunction.\n</p>\n<p>\n    The following snipped shows a possible integration test for the <b>/ping</b> endpoint.\n</p>\n<pre><code>// file: main_test.go\n\npackage main\n\nimport (\n    "fmt"\n    "net/http"\n    "net/http/httptest"\n    "testing"\n)\n\nfunc TestPingRoute(t *testing.T) {\n    // The setupServer method, that we previously refactored\n    // is injected into a test server\n    ts := httptest.NewServer(setupServer())\n    // Shut down the server and block until all requests have gone through\n    defer ts.Close()\n\n    // Make a request to our server with the {base url}/ping\n    resp, err := http.Get(fmt.Sprintf("%s/ping", ts.URL))\n\n    if err != nil {\n        t.Fatalf("Expected no error, got %v", err)\n    }\n\n    if resp.StatusCode != 200 {\n        t.Fatalf("Expected status code 200, got %v", resp.StatusCode)\n    }\n\n    val, ok := resp.Header["Content-Type"]\n\n    // Assert that the "content-type" header is actually set\n    if !ok {\n        t.Fatalf("Expected Content-Type header to be set")\n    }\n\n    // Assert that it was set as expected\n    if val[0] != "application/json; charset=utf-8" {\n        t.Fatalf("Expected \\"application/json; charset=utf-8\\", got %s", val[0])\n    }\n}</code></pre>\n<p>\n    This is all there is to it code-wise. The rest of the magic is framework independent.\n    As shown in the example, the <b>http</b><sup>2</sup> package can be used to fire request against your endpoints.\n</p>\n<p>The following command can be used to execute the test</p>\n<pre><code class="bash">$ go test\n[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\n\n[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.\n    - using env:   export GIN_MODE=release\n    - using code:  gin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    /ping                     --\x3e test.pingEndpoint (3 handlers)\n[GIN] 2018/06/08 - 10:40:06 | 200 |         103s |       127.0.0.1 | GET      /ping\nPASS\nok      test      0.022s</code></pre>\n\n<h3>Good Practices</h3>\n<p>\n    Here are a few guidelines when doing integration tests together with a http framework:\n</p>\n<ul>\n    <li>\n        Focus on one part of the system at a time.\n        <ul>\n            <li>\n                Testing the database in conjunction with the http router is time \n                consuming and results in fragile tests\n            </li>\n            <li>\n                Any other part of the system should be designed with testing in mind. \n                Use interfaces to improve the overall testability of your code\n            </li>\n        </ul>\n    </li>\n    <li>The HTTP headers and status codes should be tested rigurously</li>\n    <li>Form validation errors are also a good place to start</li>\n    <li>It\'s a good idea to use TDD to get jump-started writing testable code</li>\n</ul>\n<hr>\n<h3>References</h3>\n<ol class="references">\n    <li>\n        <a target="_blank" href="https://github.com/gin-gonic/gin#quick-start">A quick start guide to set up the <b>Gin</b> framework</a>\n    </li>\n    <li>\n        <a target="_blank" href="https://golang.org/pkg/net/http/">The golang <b>http</b> package</a>\n    </li>\n</ol>'}]},mdYu:function(e,n,t){"use strict";var o=t("Drq1"),i=t.n(o);i.a},nNx0:function(e,n,t){"use strict";var o=t("uWEC"),i=t.n(o);i.a},uWEC:function(e,n,t){},uXj7:function(e,n,t){"use strict";var o=t("dsyQ"),i=t.n(o);i.a}});
//# sourceMappingURL=app.789d7a0f.js.map