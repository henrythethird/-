<date>17 June, 2018</date>
<h2>The Agile Developer</h2>
<p>
    Agile software development has a prodound impact on the way
    we think about writing software in the modern era. Most of
    us come from a <b>Waterfall regime</b>. 
</p>

<h2>Mini Waterfall</h2>
<p>
    First steps in an agile world with a framework such as Scrum
    leads to what I like to call <b>Mini Waterfall</b>. Instead
    of planning ahead for the entire project, the team now creates
    a strict plan only for the next iteration.
</p>

<h2>Embracing Uncertainty</h2>
<p>
    Waterfall provides this tranquilizing reassurance that a project
    is going to be a success. On the one hand, the managers of the 
    development company can tell months in advance when they have what 
    <em>resource utilization</em>. And on the other hand, the clients
    get a strict plan <b>when</b> they will receive <b>what</b> according 
    to their specification. It's a win-win, right?
</p>
<p>
    Unfortunately, software development in the real world is much more -
    let's say <em>complicated</em> than that.
</p>
<p>
    Both for the client and the development teams
</p>

<h2>Evolving Architecture</h2>
<p>
    Overengineering
</p>


<h2>Conclusion</h2>
<ul>
    <li>False security through micro planning of the software cycle</li>
    <li>Leap of Faith</li>
</ul>