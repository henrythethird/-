<date>June 22, 2018</date>
<h2>CI/CD Pipeline</h2>
<p>
    <b>Continuous Integration</b> (CI) and <b>Continuous Delivery</b> (CD) are essential to
    fast delivery of software. Getting ramped up can be quite cumbersome. This
    post aims at providing a jump start.
</p>
<p>
    First things first, we have to define the two terms
</p>
<blockquote>
    <b>Continuous Integration</b> is a practice of automatically running tests, inspecting code, and building project artifacts to create a continuous feedback loop about the state of the project. It's a verification that the changes can be released without causing a hassle.
</blockquote>
<blockquote>
    <b>Continuous Delivery</b> is a practice of continuously creating working and reliable software increments (without deployment)
</blockquote>
<p>
    The pipeline gets triggered after each commit to the VCS to provide developers 
    with instant feedback about the current project status. The following are a non-exhaustive
    list of steps to consider in a pipeline
</p>
<ul>
    <li>Checkout the project from the VCS</li>
    <li>Install dependencies</li>
    <li>Static code testing</li>
    <li>Dynamic code testing</li>
    <li>Building the deployment artifact</li>
    <li>Deployment to a non-production environment</li>
</ul>
<p>
    These steps make sure that the process is repeatable and reproducible on a generic
    environment. Let's go through these steps one by one. Here examples for the first two steps
</p>
<pre><code class="bash"># Step one: fetch the code from the repository
$ git clone ssh://git@example.com/path/to/repo.git
# for node dependencies:
$ npm install
# for golang dependencies:
$ dep ensure
</code></pre>
<p>
    The important thing to note here is that for checking out the code you need
    the appropriate access to the repository. It is common practice to issue a
    access token to the CI server for that purpose. Alternatively, a ssh key can
    be generated on the CI server and be added to the runner.
</p>

<h2>Static Code Testing</h2>
<p>
    Static properties of the code base can be used as a first quality gate. There are
    various static code analysis methods
</p>
<ul>
    <li>
        Linting - Make sure that the source code conforms to the standard and doesn't 
        raise any compiler problems
    </li>
    <li>Mess detection - Measure how "messy" the code is</li>
    <li>Dependency analysis - Ensure that the code follows <em>loose coupling</em></li>
    <li>Security checking - Detect security vulnerabilities early on</li>
</ul>
<p>
    Golang for example features the <b>golint</b> command
</p>
<pre><code class="bash">$ golint $(go list ./... | grep -v /vendor/)
</code></pre>
<p>
    This command returns a non-zero exit code when there are issues with the code base.
</p>

<h2></h2>

<h2>Conclusion</h2>
<p>
    Best practices
</p>
<ul>
    <li>Trigger the pipeline with every commit</li>
    <li>
        Feedback from the pipeline should be fast
        <ul>
            <li>Fail early - abort the pipeline if a single stage fails</li>
            <li>Consider 10 minutes as a glass ceiling</li>
            <li>If you have test that take too long, consider optimizing or running these tests seperately</li>
        </ul>
    </li>
    <li>If the pipeline fails, it's the utmost priority of the team to fix it</li>
</ul>